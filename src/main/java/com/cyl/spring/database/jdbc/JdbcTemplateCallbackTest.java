package com.cyl.spring.database.jdbc;

import org.junit.*;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.*;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.jdbc.support.rowset.SqlRowSet;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 *
 * jdbcTemplate支持的回调类：
 * 1、预编译语句及存储过程创建回调：用于根据jdbctemplate提供的链接创建相应的语句
 *      PreparedStatementCreator：通过回调获取jdbcTemplate提供的Connection，由用户使用该connection创建相关的PreparedStatement
 *      callableStatementCreator：通过回调获取jdbctemplate提供的connection，由用户使用该connection创建相关的callablestatement
 * 2、预编译语句设值回调：用于给预编译语句设值相应的参数值
 *      PreparedStatementSetter:
 *      BetchPreparedStatementSetter:
 * 3、自定义功能回调：提供给用户一个扩展点，用户可以在指定类型的扩展点执行任务数量需要的操作；
 *      connectionCallback：通过回调获取jdbctemplate提供的connection，用户可在该connection支持两个任何数量的操作；
 *      statementCallback：通过回调获取jdbctemplate提供的statement，用户可以在该statement支持了任何数量的操作；
 *      preparedStatement：通过回调获取jdbctemplate提供的preparedStatement，用户可以在该preparedStatement支持两个任何数量的操作；
 *      callableStatementCallback：通过回调获取callableStatement
 * 4、结果集处理回调：通过回调处理resultSet或将resultSet转换成需要的形式
 *      rowMapper：用于将结果集每行数据转换为需要的类型，用户需要实现方法mapRow(ResultSet rs, int rowNum)完成转换工作；
 *      rowCallbackHandler:用于处理resultset的每一行结果，实现processRow(ResultSet rs)完成处理，无需实现rs.next()
 *      resultSetExtrator:y用于结果集数据提取，实现方法extractData(ResultSet rs)，必须处理整个结果集；
 *
 *
 */
public class JdbcTemplateCallbackTest {

    private static JdbcTemplate jdbcTemplate;

    @BeforeClass
    public static void setUpClass() {
        String url = "jdbc:hsqldb:mem:test";
        String userName = "sa";
        String passWord = "";
        DriverManagerDataSource dataSource = new DriverManagerDataSource(url,userName,passWord);
        dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
        jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Before
    public void setUp() {
        String creatTableSql = "create memory table test " +
                "(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name varchar(100))";
        jdbcTemplate.update(creatTableSql);
    }

    @After
    public void tearDown() {
        String dropTableSql = "drop table test";
        jdbcTemplate.update(dropTableSql);
    }


    /**
     *  预编译语句及存储过程创建回调、自定义功能回调使用；
     *
     */
    @Test
    public void testPrepareStatement() {
        int count = jdbcTemplate.execute(new PreparedStatementCreator() {
            public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                return con.prepareStatement("SELECT count(*) FROM test");
            }
        }, new PreparedStatementCallback<Integer>() {
            @Override
            public Integer doInPreparedStatement(PreparedStatement ps) throws SQLException, DataAccessException {
                ps.execute();
                ResultSet resultSet = ps.getResultSet();
                resultSet.next();
                return resultSet.getInt(1);
            }
        });
        Assert.assertEquals(0,count);
    }

    /**
     * 预编译语句设值回调使用
     */
    @Test
    public void testPrepareStatement2() {
        String insertSql = "insert into test(name) values (?)";
        int count = jdbcTemplate.update(insertSql, new PreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps) throws SQLException {
                ps.setObject(1,"name4");
            }
        });
        Assert.assertEquals(1, count);
        String deleteSql = "delete from test where name=?";
        //内部使用update(String sql, PreparedStatementSetter pss)
        count = jdbcTemplate.update(deleteSql, new Object[]{"name3"});
        Assert.assertEquals(1,count);
    }


    /**
     * 结果集处理回调RowMapper
     */
    @Test
    public void testResultSet1() {
        jdbcTemplate.update("INSERT INTO test(name) VALUES ('name5')");
        String listSql = "select * from test";
        List result = jdbcTemplate.query(listSql, new RowMapper<Map>() {
            @Override
            public Map mapRow(ResultSet rs, int rowNum) throws SQLException {
                Map row = new HashMap();
                row.put(rs.getInt("id"),rs.getString("name"));
                return row;
            }
        });
        System.out.println(result);
        Assert.assertEquals(1,result.size());
        jdbcTemplate.update("DELETE FROM test WHERE name='name5'");
    }

    /**
     * 结果集处理回调：RowCallbackHandler
     */
    @Test
    public void testResultSet2() {
        jdbcTemplate.update("INSERT INTO test(name) VALUES ('name5')");
        String listSql = "select * from test";
        List resultList = new ArrayList();
        jdbcTemplate.query(listSql, new RowCallbackHandler() {
            @Override
            public void processRow(ResultSet rs) throws SQLException {
                Map row = new HashMap();
                row.put(rs.getInt("id"), rs.getString("name5"));
                resultList.add(row);
            }
        });
        System.out.println(resultList);
        Assert.assertEquals(1,resultList.size());
        jdbcTemplate.update("DELETE FROM test WHERE name='name5'");
    }

    @Test
    public void testResultSet3() {
        jdbcTemplate.update("INSERT INTO test(name) VALUES ('name5')");
        jdbcTemplate.update("INSERT INTO test(name) VALUES ('name4')");
        String listSql = "select * from test";
        List result = jdbcTemplate.query(listSql,new ResultSetExtractor<List>(){

            @Override
            public List extractData(ResultSet rs) throws SQLException, DataAccessException {
                List result = new ArrayList();
                while (rs.next()) {
                    Map row = new HashMap();
                    row.put(rs.getInt("id"), rs.getString("name"));
                    result.add(row);
                }
                return result;
            }
        });
        System.out.println(result);
        Assert.assertEquals(0,result.size());
        jdbcTemplate.update("DELETE FROM test WHERE name='name5'");
    }

    @Test
    public void test() {
        jdbcTemplate.update("INSERT INTO test(name) VALUES ('name5')");

        //内部全部通过query(final String sql, final ResultSetExtractor<T> rse)实现
        //1、查询一行数据并map结果
        System.out.println(jdbcTemplate.queryForMap("SELECT * FROM test where name='name5'"));
        //2、查询一行任何类型的数据，最后一个参数指定返回结果类型
        System.out.println(jdbcTemplate.queryForObject("SELECT count(*) FROM test",Integer.class));
        //3、查询一批数据，将每行数据转换成map
        System.out.println(jdbcTemplate.queryForList("SELECT * FROM test"));
        //4、只查询一列数据，列类型为string类型，列名为name
        System.out.println(jdbcTemplate.queryForList("SELECT name FROM test WHERE name=?",new Object[]{"name5"},String.class));
        //5、查询一批数据，返回sqlrowset，类似于resultSet，但不在绑定在连接上
        System.out.println(jdbcTemplate.queryForRowSet("SELECT * FROM test"));
    }


}
